
//---------------------------------------------------------------------------

// This software is Copyright (c) 2011 Embarcadero Technologies, Inc. 
// You may only use this software if you are an authorized licensee
// of Delphi, C++Builder or RAD Studio (Embarcadero Products).
// This software is considered a Redistributable as defined under
// the software license agreement that comes with the Embarcadero Products
// and is subject to that software license agreement.

//---------------------------------------------------------------------------
unit DBXUtilsTests;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework, DB, DBXTypedTableStorage, DBXUtils, SqlExpr, Classes, DBXCommonTable,
  SysUtils, DBXCommon, DBXMetaDataReader, DBXMetaDataWriter,
  DBXMetaDataProvider, DBClient, Generics.Collections;

type

  TAnonMethod = reference to procedure;

  TTestTable = class
  private
    FInt64Field: Int64;
    FDecimalField: Double;
    FSingleField: Single;
    FStringField: string;
    FMemoField: string;
    FID: Integer;
    FDoubleField: Double;
    FInt32Field: Integer;
    FTestTableID: Integer;
    FDateField: TDateTime;
  public
    property ID: Integer read FID write FID;
    property TestTableID: Integer read FTestTableID write FTestTableID;
    property StringField: string read FStringField write FStringField;
    property Int32Field: Integer read FInt32Field write FInt32Field;
    property DoubleField: Double read FDoubleField write FDoubleField;
    property MemoField: string read FMemoField write FMemoField;
    property DecimalField: Double read FDecimalField write FDecimalField;
    property Int64Field: Int64 read FInt64Field write FInt64Field;
    property SingleField: Single read FSingleField write FSingleField;
    property DateField: TDateTime read FDateField write FDateField;
  end;

  TDBXUtilsTests = class(TTestCase)
  private
    FConnection: TSQLConnection;
    FDateValue: TDateTime;
    FBlobValue: TBytes;
    FAnonMethod: TAnonMethod;
    procedure CallAnonMethod;
    procedure CheckExceptionEx(AMethod: TAnonMethod; AExceptionClass: TClass;
      AExceptionText: string = ''; msg: string = ''); overload;
    procedure CheckExceptionEx(AMethod: TTestMethod; AExceptionClass: TClass;
      AExceptionText: string = ''; msg: string = ''); overload;

    procedure PopulateTestTable;
    procedure VerifyDates(const AExpected, AActual: TDateTime);
    procedure VerifyBytes(const AExpected, AActual: TBytes);
    procedure VerifyParam(AParam: TParam; const AExpectedName: string;
      const AExpectedDataType: TFieldType; AExpectedValue: Variant;
      AExpectedParamType: TParamType; AExpectedSize: Integer);
    procedure VerifyCDS(ADataSet: TClientDataSet; AIsEmpty: Boolean);
    procedure VerifyConnection(AConnection: TSQLConnection; AFree: Boolean = True;
      AExtraProc: TProc = nil);
    procedure ClearProps(AConnection: TSQLConnection);
    procedure VerifyList(ADataSet: TDataSet; AList: TObjectList<TTestTable>; ASmartID: Boolean);
    procedure VerifyObject(ADataSet: TDataSet; AObject: TTestTable; ASmartID: Boolean);
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure CreateConnectionTest;
    procedure InitConnectionTest;

    procedure CreateConnectionNameTest;
    procedure InitConnectionNameTest;

    procedure CreateConnectionPropsTest;
    procedure InitConnectionPropsTest;

    procedure GetValueTest;
    procedure QueryValueTest;
    procedure GetCountTest;
    procedure GetValueNullDefaultTest;
    procedure QueryValueNullDefaultTest;
    procedure GetBytesTest;
    procedure GetMemoTest;
    procedure MakeParamTest;
    procedure MakeParamListTest;
    procedure ExecNoQueryTest;
    procedure ExecProcTest;
    procedure CreateDataSetTest;
    procedure GetDataSetTest;
    procedure GetClientDataSetTest;
    procedure DataSetToCDSTest;

    procedure PropNameToFieldNameTest;
    procedure FieldNameToPropNameTest;
    procedure ListFromSQLTest;
    procedure ListFromDataSetTest;
    procedure ObjectFromDataSetTest;

    procedure TorFTest;
    procedure YorNTest;
  end;

implementation

uses
  DbxInterbase;

const
  cnTestConnection = 'DBUtilsTest';
  cnTestConnectionIni = 'DBUtilsTestIni';
  cnInvalidConnection = 'DUnitInvalidConnection';
  cnInvalidIni = 'DUnitInvalidIni';
  cnUserName = 'sysdba';
  cnPassword = 'masterkey';
  cnDatabase = 'localhost:c:\radstudiodemos\branches\RadStudio_XE3_Update\Delphi\Database\dbExpress\Utils\Tests\Data\dbutilstest.ib';
  cnDriver = 'INTERBASE';
  cnInvalidDriver = 'DUnitInvalidDriver';

  cnIDValue = 6;
  cnStringValue = 'Test';
  cnDecimalValue = 1.23456;
  cnDoubleValue = 1.5;
  cnSingleValue = 0.75;
  cnInt32Value = 42;
  cnInt64Value = MaxLongInt;
  cnMemoValue = 'MemoTest';

  cnSelectAll = 'SELECT * FROM TEST_TABLE';

  cnSelectStringField = 'select string_field from test_table';
  cnWhereNotHere = ' where 0 = 1';
  cnSelectStringFieldNotHere = cnSelectStringField + cnWhereNotHere;
  cnSelectStringFieldNull = 'select null as string_field from test_table';
  cnStringDefault = 'oops';
  cnStringNullDefault = 'oopsnull';

  cnSelectInt32Field = 'select int32_field from test_table';
  cnSelectInt32FieldNotHere = cnSelectInt32Field + cnWhereNotHere;
  cnSelectInt32FieldNull = 'select null as int32_field from test_table';
  cnInt32Default = -1;
  cnInt32NullDefault = 0;

  cnSelectInt64Field = 'select int64_field from test_table';
  cnSelectInt64FieldNotHere = cnSelectInt64Field + cnWhereNotHere;
  cnSelectInt64FieldNull =  'select null as int64_field from test_table';
  cnSelectInt64FieldParam = cnSelectInt64Field + ' where int64_field = :val';
  cnSelectInt64FieldParamNull = cnSelectInt64FieldNull + ' where int64_field = :val';
  cnInt64Default = -1;
  cnInt64NullDefault = 0;

  cnSelectDoubleField = 'select double_field from test_table';
  cnSelectDoubleFieldNotHere = cnSelectDoubleField + cnWhereNotHere;
  cnSelectDoubleFieldNull = 'select null as double_field from test_table';
  cnDoubleDefault = -1;
  cnDoubleNullDefault = 0;

  cnSelectDateField = 'select date_field from test_table';
  cnSelectDateFieldNotHere = cnSelectDateField + cnWhereNotHere;
  cnSelectDateFieldNull = 'select null as date_field from test_table';
  cnDateDefault = 0;
  cnDateNullDefault = 1;

resourcestring
  sExceptionNothing = 'nothing';

procedure TDBXUtilsTests.CheckExceptionEx(AMethod: TAnonMethod;
  AExceptionClass: TClass; AExceptionText, msg: string);
begin
  FAnonMethod := AMethod;
  CheckExceptionEx(CallAnonMethod, AExceptionClass, AExceptionText, msg);
end;

procedure TDBXUtilsTests.CallAnonMethod;
begin
  CheckTrue(Assigned(FAnonMethod), 'CheckExceptionEx: AMethod not specified');
  FAnonMethod;
end;

procedure TDBXUtilsTests.CheckExceptionEx(AMethod: TTestMethod;
  AExceptionClass: TClass; AExceptionText, msg: string);
begin
  FCheckCalled := True;
  try
    Invoke(AMethod);
  except
    on e :Exception do
    begin
      if  not Assigned(AExceptionClass) then
        raise
      else if not e.ClassType.InheritsFrom(AExceptionClass) then
        FailNotEquals(AExceptionClass.ClassName, e.ClassName, msg, ReturnAddress)
      else if (AExceptionText <> '') and (AExceptionText <> e.Message) then
        FailNotEquals(AExceptionText, e.Message, msg, ReturnAddress)
      else
        AExceptionClass := nil;
    end;
  end;
  if Assigned(AExceptionClass) then
    FailNotEquals(AExceptionClass.ClassName, sExceptionNothing, msg, ReturnAddress)
end;

procedure TDBXUtilsTests.CreateConnectionNameTest;
var
  lConnection: TSQLConnection;
begin
  lConnection := CreateConnectionName(cnTestConnection);
  VerifyConnection(lConnection, True, procedure
    begin
      CheckEqualsString(cnTestConnection, lConnection.ConnectionName);
    end);

  CheckExceptionEx(procedure begin
    CreateConnectionName(cnInvalidConnection);
  end, TDBXError, 'Invalid argument:  ' + cnInvalidConnection);
end;


procedure TDBXUtilsTests.InitConnectionNameTest;
var
  lConnection: TSQLConnection;
begin
  lConnection := TSQLConnection.Create(nil);
  try
    InitConnectionName(lConnection, cnTestConnection);
    VerifyConnection(lConnection, False, procedure
      begin
        CheckEqualsString(cnTestConnection, lConnection.ConnectionName);
      end);

    ClearProps(lConnection);
    CheckExceptionEx(procedure begin
      CreateConnectionName(cnInvalidConnection);
    end, TDBXError, 'Invalid argument:  ' + cnInvalidConnection);
  finally
    lConnection.Free;
  end;
end;

procedure TDBXUtilsTests.VerifyBytes(const AExpected, AActual: TBytes);
var
  i: Integer;
begin
  CheckEquals(Length(AExpected), Length(AActual), 'Length');
  for i := Low(AExpected) to High(AExpected) do
    CheckEquals(AExpected[i], AActual[i], Format('Byte %d', [i]));
end;

procedure TDBXUtilsTests.VerifyDates(const AExpected, AActual: TDateTime);
var
  ExpYear, ExpMonth, ExpDay, ExpHour, ExpMin, ExpSec, ExpMsec: Word;
  ActYear, ActMonth, ActDay, ActHour, ActMin, ActSec, ActMsec: Word;
begin
  DecodeDate(AExpected, ExpYear, ExpMonth, ExpDay);
  DecodeTime(AExpected, ExpHour, ExpMin, ExpSec, ExpMsec);
  DecodeDate(AActual, ActYear, ActMonth, ActDay);
  DecodeTime(AActual, ActHour, ActMin, ActSec, ActMsec);

  CheckEquals(ExpYear, ActYear, 'Year');
  CheckEquals(ExpMonth, ActMonth, 'Month');
  CheckEquals(ExpDay, ActDay, 'Day');
  CheckEquals(ExpHour, ActHour, 'Hour');
  CheckEquals(ExpMin, ActMin, 'Min');
  CheckEquals(ExpSec, ActSec, 'Sec');
end;

procedure TDBXUtilsTests.CreateConnectionPropsTest;
var
  lCon: TSQLConnection;
begin
  lCon := CreateConnectionProps(cnDatabase, cnUserName, cnPassword);
  VerifyConnection(lCon);
  lCon := CreateConnectionProps(cnDatabase, cnUserName, cnPassword, cnDriver);
  VerifyConnection(lCon);

  CheckExceptionEx(procedure
    begin
      CreateConnectionProps(cnDatabase, cnUserName, cnPassword, cnInvalidDriver);
    end, TDBXError);
end;

procedure TDBXUtilsTests.InitConnectionPropsTest;
var
  lCon: TSQLConnection;
begin
  lCon := TSQLConnection.Create(nil);
  try
    InitConnectionProps(lCon, cnDatabase, cnUserName, cnPassword);
    VerifyConnection(lCon, False);

    ClearProps(lCon);
    InitConnectionProps(lCon, cnDatabase, cnUserName, cnPassword, cnDriver);
    VerifyConnection(lCon, False);

    ClearProps(lCon);
    CheckExceptionEx(procedure
      begin
        CreateConnectionProps(cnDatabase, cnUserName, cnPassword, cnInvalidDriver);
      end, TDBXError);
  finally
    lCon.Free;
  end;
end;

procedure TDBXUtilsTests.VerifyConnection(AConnection: TSQLConnection;
  AFree: Boolean = True; AExtraProc: TProc = nil);
begin
  try
    CheckNotNull(AConnection, 'Connection not assigned');
    CheckTrue(AConnection.ConnectionState = csStateOpen, 'Connection not open');
    if Assigned(AExtraProc) then
      AExtraProc;
    AConnection.Close;
  finally
    if AFree then
    begin
      AConnection.Free;
    end;
  end;
end;

procedure TDBXUtilsTests.CreateConnectionTest;
var
  lConnection: TSQLConnection;
begin
  lConnection := CreateConnection(cnTestConnection);
  VerifyConnection(lConnection);

  lConnection := CreateConnection(cnTestConnection, ModuleIniFile);
  VerifyConnection(lConnection);

  lConnection := CreateConnection(cnTestConnection);
  VerifyConnection(lConnection, True, procedure
    begin
      CheckEqualsString(cnTestConnection, lConnection.ConnectionName);
    end);

  CheckExceptionEx(procedure
    begin
      CreateConnection(cnInvalidConnection);
    end, EDBXUtils, Format(StrCouldNotOpenConnection, [cnInvalidConnection,
      'DBX Error:  Database must be specified.', 'Invalid argument:  ' + cnInvalidConnection]));

  CheckExceptionEx(procedure
    begin
      CreateConnection(cnTestConnectionIni, cnInvalidIni);
    end, EDBXUtils, Format(StrCouldNotOpenConnection, [cnTestConnectionIni,
      Format(StrAppIniMissing, [cnInvalidIni]), 'Invalid argument:  ' + cnTestConnectionIni]));
end;


procedure TDBXUtilsTests.ClearProps(AConnection: TSQLConnection);
begin
  AConnection.Params.Text := '';
  AConnection.ConnectionName := '';
end;

procedure TDBXUtilsTests.InitConnectionTest;
var
  lConnection: TSQLConnection;
begin
  lConnection := TSQLConnection.Create(nil);
  try
    InitConnection(lConnection, cnTestConnectionIni);
    VerifyConnection(lConnection, False);

    //Recreate the connection each time for this test, so we don't have to
    //clear properties to ensure we know
    ClearProps(lConnection);
    InitConnection(lConnection, cnTestConnectionIni, ModuleIniFile);
    VerifyConnection(lConnection, False);

    ClearProps(lConnection);
    InitConnection(lConnection, cnTestConnection);
    VerifyConnection(lConnection, False, procedure
      begin
        CheckEqualsString(cnTestConnection, lConnection.ConnectionName);
      end);

    ClearProps(lConnection);
    CheckExceptionEx(procedure
      begin
        InitConnection(lConnection, cnInvalidConnection);
      end, EDBXUtils, Format(StrCouldNotOpenConnection, [cnInvalidConnection,
        'DBX Error:  Database must be specified.', 'Invalid argument:  ' + cnInvalidConnection]));

    ClearProps(lConnection);
    CheckExceptionEx(procedure
      begin
        InitConnection(lConnection, cnTestConnectionIni, cnInvalidIni);
      end, EDBXUtils, Format(StrCouldNotOpenConnection, [cnTestConnectionIni,
        Format(StrAppIniMissing, [cnInvalidIni]), 'Invalid argument:  ' + cnTestConnectionIni]));
  finally
    lConnection.Free;
  end;
end;

procedure TDBXUtilsTests.CreateDataSetTest;
var
  lRetVal: TSQLDataSet;

  procedure VerifyDataSet(const AExpectedSQL: string; AExpectedType: TSQLCommandType);
  begin
    CheckNotNull(lRetVal);
    CheckEqualsString(AExpectedSQL, lRetVal.CommandText);
    CheckTrue(AExpectedType = lRetVal.CommandType);
    CheckTrue(lRetVal.State = dsInactive);
  end;

begin
  lRetVal := CreateDataSet(FConnection, 'select foo from bar');
  try
    VerifyDataSet('select foo from bar', ctQuery);
  finally
    lRetVal.Free;
  end;

  lRetVal := CreateDataSet(FConnection, 'some_proc', ctStoredProc);
  try
    VerifyDataSet('some_proc', ctStoredProc);
  finally
    lRetVal.Free;
  end;
end;

procedure TDBXUtilsTests.DataSetToCDSTest;
var
  lDataSet: TSQLDataSet;
  lCDS: TClientDataSet;
  lField: TField;
begin
  lDataSet := GetDataSet(FConnection, 'select int32_field, int64_field from test_table');
  try
    lCDS := DataSetToCDS(lDataSet);
    try
      CheckNotNull(lCDS);
      CheckEquals(lDataSet.RecordCount, lCDS.RecordCount);
      CheckEquals(lDataSet.FieldCount, lCDS.FieldCount);
      lDataSet.First;
      for lField in lDataSet.Fields do
        CheckEquals(lField.AsLargeInt, lCDS.FieldByName(lField.FieldName).AsLargeInt);
    finally
      lCDS.Free;
    end;
  finally
    lDataSet.Free;
  end;
end;

procedure TDBXUtilsTests.ExecNoQueryTest;
var
  lVal: Integer;
  lParams: TParams;
begin
  lVal := GetValue(FConnection, 'int32_field', 'test_table', -1);
  CheckEquals(cnInt32Value, lVal);

  CheckEquals(ExecNoQuery(FConnection, Format('update test_table set int32_field = %d', [cnInt32Value * 2])), 1);
  lVal := GetValue(FConnection, 'int32_field', 'test_table', -1);
  CheckEquals(cnInt32Value * 2, lVal);

  lParams := MakeParamList('val', ftInteger, cnInt32Value * 4);
  CheckEquals(ExecNoQuery(FConnection, 'update test_table set int32_field = :val',
    lParams, False), 1);
  lVal := GetValue(FConnection, 'int32_field', 'test_table', -1);
  CheckEquals(cnInt32Value * 4, lVal);
  CheckEquals(ExecNoQuery(FConnection,
    'update test_table set int32_field = int32_field - :val', lParams, True), 1);
  lVal := GetValue(FConnection, 'int32_field', 'test_table', -1);
  CheckEquals(0, lVal);
end;

procedure TDBXUtilsTests.ExecProcTest;
var
  lParams: TParams;
  lRetVal: Double;
begin
  ExecProc(FConnection, 'TEST_PROC');
  ExecProc(FConnection, 'TEST_PROC_WITH_PARAM', MakeParamList('PARAM', ftInteger, cnInt32Value));

  lParams := MakeParamList(
    [MakeParam('PARAM', ftInteger, cnInt32Value),
     MakeParam('RETURN_VALUE', ftLargeInt, 0, ptOutput)]);
  try
    //lRetVal := ExecProc(FConnection, 'TEST_PROC_WITH_RETURN_VALUE', lParams, False);
    //CheckEquals(cnInt32Value * 2, lRetVal);

    lRetVal := ExecProc(FConnection, 'TEST_PROC_WITH_RETURN_VALUE', lParams, False,
      'RETURN_VALUE', False);
    CheckEquals(cnInt32Value * 2, lRetVal);

  finally
    lParams.Free;
  end;



end;


procedure TDBXUtilsTests.GetBytesTest;
var
  lRetVal: TBytes;
  lExpected: TBytes;
  i: Integer;
  lParams: TParams;
begin
  SetLength(lExpected, 3);
  for i := Low(lExpected) to High(lExpected) do
    lExpected[i] := i;

  lRetVal := GetBytes(FConnection, 'blob_field', 'test_table', nil);
  VerifyBytes(FBlobValue, lRetVal);
  lRetVal := GetBytes(FConnection, 'blob_field', 'test_table', lExpected, '0 = 1');
  VerifyBytes(lExpected, lRetVal);

  lParams := MakeParamList('val', ftInteger, 0);
  lRetVal := GetBytes(FConnection, 'blob_field', 'test_table', nil, '0 = :val',
    lParams, False);
  VerifyBytes(FBlobValue, lRetVal);
  lRetVal := GetBytes(FConnection, 'blob_field', 'test_table', nil, '0 = :val',
    lParams, True);
  VerifyBytes(FBlobValue, lRetVal);
end;

procedure TDBXUtilsTests.VerifyCDS(ADataSet: TClientDataSet; AIsEmpty: Boolean);
begin
  CheckNotNull(ADataSet);
  CheckEquals(2, ADataSet.FieldCount);
  CheckTrue(ADataSet.State = dsBrowse);
  if AIsEmpty then
    CheckEquals(0, ADataSet.RecordCount)
  else
  begin
    CheckEquals(1, ADataSet.RecordCount);
    CheckEquals(cnInt32Value, ADataSet.FieldByName('int32_field').AsInteger);
    CheckEquals(cnInt64Value, ADataSet.FieldByName('int64_field').AsLargeInt);
    ADataSet.Next;
    CheckTrue(ADataSet.Eof);
  end;
end;

procedure TDBXUtilsTests.GetClientDataSetTest;
var
  lRetVal: TClientDataSet;
  lParams: TParams;
begin
  lRetVal := GetClientDataSet(FConnection,
    'select int32_field, int64_field from test_table');
  try
    VerifyCDS(lRetVal, False);
  finally
    lRetVal.Free;
  end;

  lRetVal := GetClientDataSet(FConnection,
    'select int32_field, int64_field from test_table', nil, True, False);
  try
    VerifyCDS(lRetVal, False);
  finally
    lRetVal.Free;
  end;

  lParams := MakeParamList('int32_field', ftInteger, cnInt32Value);
  lRetVal := GetClientDataSet(FConnection, 'select int32_field, int64_field from test_table where int32_field = :int32_field', lParams, False);
  try
    VerifyCDS(lRetVal, False);
  finally
    lRetVal.Free;
  end;

  lParams[0].Value := cnInt32Value + 1;
  lRetVal := GetClientDataSet(FConnection, 'select int32_field, int64_field from test_table where int32_field = :val', lParams, True);
  try
    VerifyCDS(lRetVal, True);
  finally
    lRetVal.Free;
  end;

  lRetVal := GetClientDataSet(FConnection, 'int32_field, int64_field', 'test_table');
  try
    VerifyCDS(lRetVal, False);
  finally
    lRetVal.Free;
  end;

  lParams := MakeParamList('val', ftInteger, cnInt32Value);
  lRetVal := GetClientDataSet(FConnection, 'int32_field, int64_field', 'test_table', 'int32_field = :val', lParams, False);
  try
    VerifyCDS(lRetVal, False);
  finally
    lRetVal.Free;
  end;

  lParams[0].Value := cnInt32Value + 1;
  lRetVal := GetClientDataSet(FConnection, 'int32_field, int64_field', 'test_table', 'int32_field = :val', lParams, True);
  try
    VerifyCDS(lRetVal, True);
  finally
    lRetVal.Free;
  end;
end;

procedure TDBXUtilsTests.GetCountTest;
begin
  CheckEquals(1, GetCount(FConnection, 'test_table',
    'string_field = :string_field',
      MakeParamList('string_field', ftString, cnStringValue)));
  CheckEquals(0, GetCount(FConnection, 'test_table',
    'string_field = :string_field',
      MakeParamList('string_field', ftString, cnStringValue + 'foo')));
end;

procedure TDBXUtilsTests.GetDataSetTest;
var
  lRetVal: TSQLDataSet;
  lParams: TParams;

  procedure VerifyDataSet(AIsEmpty: Boolean);
  begin
    CheckNotNull(lRetVal);
    CheckEquals(2, lRetVal.FieldCount);
    CheckTrue(lRetVal.State = dsBrowse);
    if AIsEmpty then
      CheckTrue(lRetVal.Bof and lRetVal.Eof)
    else
    begin
      //Gives an 'Operation Not Supported' exception for parameterized queries
      //CheckEquals(1, lRetVal.RecordCount);
      CheckFalse(lRetVal.Eof);
      CheckEquals(cnInt32Value, lRetVal.FieldByName('int32_field').AsInteger);
      CheckEquals(cnInt64Value, lRetVal.FieldByName('int64_field').AsLargeInt);
      lRetVal.Next;
      CheckTrue(lRetVal.Eof);
    end;
  end;

begin
  lRetVal := GetDataSet(FConnection, 'select int32_field, int64_field from test_table');
  try
    VerifyDataSet(False);
  finally
    lRetVal.Free;
  end;

  lRetVal := GetDataSet(FConnection, 'select int32_field, int64_field from test_table',nil, False, nil, False);
  try
    VerifyDataSet(False);
  finally
    lRetVal.Free;
  end;

  lParams := MakeParamList('int32_field', ftInteger, cnInt32Value);
  lRetVal := GetDataSet(FConnection, 'select int32_field, int64_field from test_table where int32_field = :int32_field', lParams, False);
  try
    VerifyDataSet(False);
  finally
    lRetVal.Free;
  end;

  lParams[0].Value := cnInt32Value + 1;
  lRetVal := GetDataSet(FConnection, 'select int32_field, int64_field from test_table where int32_field = :val', lParams, True);
  try
    VerifyDataSet(True);
  finally
    lRetVal.Free;
  end;

  lRetVal := GetDataSet(FConnection, 'int32_field, int64_field', 'test_table');
  try
    VerifyDataSet(False);
  finally
    lRetVal.Free;
  end;

  lParams := MakeParamList('val', ftInteger, cnInt32Value);
  lRetVal := GetDataSet(FConnection, 'int32_field, int64_field', 'test_table', 'int32_field = :val', lParams, False);
  try
    VerifyDataSet(False);
  finally
    lRetVal.Free;
  end;

  lParams[0].Value := cnInt32Value + 1;
  lRetVal := GetDataSet(FConnection, 'int32_field, int64_field', 'test_table', 'int32_field = :val', lParams, True);
  try
    VerifyDataSet(True);
  finally
    lRetVal.Free;
  end;
end;

procedure TDBXUtilsTests.GetMemoTest;
var
  lRetVal: string;
  lParams: TParams;
begin
  lRetVal := GetMemo(FConnection, 'memo_field', 'test_table', 'oops');
  CheckEquals(cnMemoValue, lRetVal);
  lRetVal := GetValue(FConnection, 'memo_field', 'test_table', 'oops', '0 = 1');
  CheckEquals('oops', lRetVal);

  lParams := MakeParamList('val', ftInteger, 0);
  lRetVal := GetMemo(FConnection, 'memo_field', 'test_table', 'oops', '0 = :val',
    lParams, False);
  CheckEquals(cnMemoValue, lRetVal);
  lRetVal := GetMemo(FConnection, 'memo_field', 'test_table', 'oops', '0 = :val',
    lParams, True);
  CheckEquals(cnMemoValue, lRetVal);
end;

procedure TDBXUtilsTests.GetValueNullDefaultTest;
var
  lInt64: Int64;
  lInt32: Integer;
  lDouble: Double;
  lDate: TDateTime;
  lStr: string;
  lParams: TParams;
begin
  lStr := GetValueNullDefault(FConnection, 'string_field', 'test_table', 'oops', 'oopsnull');
  CheckEquals(cnStringValue, lStr);
  lStr := GetValueNullDefault(FConnection, 'string_field', 'test_table', 'oops', 'oopsnull', '0 = 1');
  CheckEquals('oops', lStr);
  lStr := GetValueNullDefault(FConnection, 'null asstring_field', 'test_table', 'oops', 'oopsnull');
  CheckEquals('oopsnull', lStr);

  lInt32 := GetValueNullDefault(FConnection, 'int32_field', 'test_table', -1, 0);
  CheckEquals(cnInt32Value, lInt32);
  lInt32 := GetValueNullDefault(FConnection, 'int32_field', 'test_table', -1, 0, '0 = 1');
  CheckEquals(-1, lInt32);
  lInt32 := GetValueNullDefault(FConnection, 'null as int32_field', 'test_table', -1, 0);
  CheckEquals(0, lInt32);

  lDouble := GetValueNullDefault(FConnection, 'double_field', 'test_table', -1, 0);
  CheckEquals(cnDoubleValue, lDouble);
  lDouble := GetValueNullDefault(FConnection, 'double_field', 'test_table', -1, 0, '0 = 1');
  CheckEquals(-1, lDouble);
  lDouble := GetValueNullDefault(FConnection, 'null as double_field', 'test_table', -1, 0);
  CheckEquals(0, lDouble);

  lDate := GetValueNullDefault(FConnection, 'date_field', 'test_table', 0, 1);
  VerifyDates(FDateValue, lDate);
  lDate := GetValueNullDefault(FConnection, 'date_field', 'test_table', 0, 1, '0 = 1');
  CheckEquals(0, lDate);
  lDate := GetValueNullDefault(FConnection, 'null as date_field', 'test_table', 0, 1);
  CheckEquals(1, lDate);

  lInt64 := GetValueNullDefault(FConnection, 'int64_field', 'test_table', -1, 0);
  CheckEquals(cnInt64Value, lInt64);
  lInt64 := GetValueNullDefault(FConnection, 'int64_field', 'test_table', -1, 0, '0 = 1');
  CheckEquals(-1, lInt64);
  lInt64 := GetValueNullDefault(FConnection, 'null as int64_field', 'test_table', -1, 0);
  CheckEquals(0, lInt64);

  lParams := MakeParamList('val', ftLargeint, cnInt64Value);
  lInt64 := GetValueNullDefault(FConnection, 'int64_field', 'test_table', -1, 0,
    'int64_field = :val', lParams, False);
  CheckEquals(cnInt64Value, lInt64);
//  lParams[0].Value := cnInt64Value + 1;
//  lInt64 := GetValueNullDefault(FConnection, 'null as nt64_field', 'test_table', -1, 0,
//    'int64_field = :val', lParams, False);
//  CheckEquals(-1, lInt64);
  lParams[0].Value := cnInt64Value;
  lInt64 := GetValueNullDefault(FConnection, 'null as nt64_field', 'test_table', -1, 0,
    'int64_field = :val', lParams, False);
  CheckEquals(0, lInt64);
  lInt64 := GetValueNullDefault(FConnection, 'int64_field', 'test_table', -1, 0,
    'int64_field = :val', lParams, True);
  CheckEquals(cnInt64Value, lInt64);
end;

procedure TDBXUtilsTests.GetValueTest;
var
  lInt64: Int64;
  lInt32: Integer;
  lDouble: Double;
  lDate: TDateTime;
  lStr: string;
  lParams: TParams;
begin
  lStr := GetValue(FConnection, 'string_field', 'test_table', 'oops');
  CheckEquals(cnStringValue, lStr);
  lStr := GetValue(FConnection, 'string_field', 'test_table', 'oops', '0 = 1');
  CheckEquals('oops', lStr);

  lInt32 := GetValue(FConnection, 'int32_field', 'test_table', -1);
  CheckEquals(cnInt32Value, lInt32);
  lInt32 := GetValue(FConnection, 'int32_field', 'test_table', -1, '0 = 1');
  CheckEquals(-1, lInt32);

  lDouble := GetValue(FConnection, 'double_field', 'test_table', -1);
  CheckEquals(cnDoubleValue, lDouble);
  lDouble := GetValue(FConnection, 'double_field', 'test_table', -1, '0 = 1');
  CheckEquals(-1, lDouble);

  lDate := GetValue(FConnection, 'date_field', 'test_table', 0);
  VerifyDates(FDateValue, lDate);
  lDate := GetValue(FConnection, 'date_field', 'test_table', 0, '0 = 1');
  CheckEquals(0, lDate);

  lInt64 := GetValue(FConnection, 'int64_field', 'test_table', -1);
  CheckEquals(cnInt64Value, lInt64);
  lInt64 := GetValue(FConnection, 'int64_field', 'test_table', -1, '0 = 1');
  CheckEquals(-1, lInt64);

  lParams := MakeParamList('val', ftLargeint, cnInt64Value);
  lInt64 := GetValue(FConnection, 'int64_field', 'test_table', -1,
    'int64_field = :val', lParams, False);
  CheckEquals(cnInt64Value, lInt64);
  lInt64 := GetValue(FConnection, 'int64_field', 'test_table', -1,
    'int64_field = :val', lParams, True);
  CheckEquals(cnInt64Value, lInt64);

  lInt32 := GetValue(FConnection, 'null as int32_field', 'test_table', -1);
  CheckEquals(-1, lInt32);
end;

procedure TDBXUtilsTests.VerifyParam(AParam: TParam; const AExpectedName: string;
  const AExpectedDataType: TFieldType; AExpectedValue: Variant;
  AExpectedParamType: TParamType; AExpectedSize: Integer);
begin
  CheckNotNull(AParam);
  CheckEqualsString(AExpectedName, AParam.Name, 'AParam.Name');
  CheckTrue(AExpectedDataType = AParam.DataType, 'AParam.DataType');
  CheckTrue(AExpectedValue = AParam.Value, 'AParam.Value');
  CheckTrue(AExpectedParamType = AParam.ParamType, 'AParam.ParamType');
  CheckEquals(AExpectedSize, AParam.Size, 'AParam.Size');
end;

procedure TDBXUtilsTests.YorNTest;
begin
  CheckEquals('Y', YOrN(True));
  CheckEquals('N', YOrN(False));
end;

procedure TDBXUtilsTests.MakeParamTest;
var
  lParam: TParam;
begin
  lParam := MakeParam('IntParam', ftInteger, 1);
  try
    VerifyParam(lParam, 'IntParam', ftInteger, 1, ptInput, 0);
  finally
    lParam.Free;
  end;

  lParam := MakeParam('FloatParam', ftFloat, 2.5, ptOutput);
  try
    VerifyParam(lParam, 'FloatParam', ftFloat, 2.5, ptOutput, 0);
  finally
    lParam.Free;
  end;

  lParam := MakeParam('StringParam', ftString, 'ParamVal', ptInputOutput, 10);
  try
    VerifyParam(lParam, 'StringParam', ftString, 'ParamVal', ptInputOutput, 10);
  finally
    lParam.Free;
  end;

  lParam := MakeParam('LongStringParam', ftString, 'ParamVal', ptInput, 3);
  try
    VerifyParam(lParam, 'LongStringParam', ftString, 'Par', ptInput, 3);
  finally
    lParam.Free;
  end;
end;

procedure TDBXUtilsTests.MakeParamListTest;
var
  lParams: TParams;
begin
  lParams := MakeParamList('IntParam', ftInteger, 1);
  try
    VerifyParam(lParams[0], 'IntParam', ftInteger, 1, ptInput, 0);
  finally
    lParams.Free;
  end;

  lParams := MakeParamList('FloatParam', ftFloat, 2.5, ptOutput);
  try
    VerifyParam(lParams[0], 'FloatParam', ftFloat, 2.5, ptOutput, 0);
  finally
    lParams.Free;
  end;

  lParams := MakeParamList('StringParam', ftString, 'ParamVal', ptInputOutput, 10);
  try
    VerifyParam(lParams[0], 'StringParam', ftString, 'ParamVal', ptInputOutput, 10);
  finally
    lParams.Free;
  end;

  lParams := MakeParamList('LongStringParam', ftString, 'ParamVal', ptInput, 3);
  try
    VerifyParam(lParams[0], 'LongStringParam', ftString, 'Par', ptInput, 3);
  finally
    lParams.Free;
  end;
end;


procedure TDBXUtilsTests.PopulateTestTable;
const
  cnInsertSQL =
    'insert into test_table(test_table_id, string_field, int32_field, double_field, date_field, ' +
    'memo_field, decimal_field, int64_field, blob_field, single_field) ' +
    'values (:test_table_id, :string_field, :int32_field, :double_field, :date_field, ' +
    ':memo_field, :decimal_field, :int64_field, :blob_field, :single_field)';
  cnBlobLength = ($FFFF * 2) + 5;
var
  lDataSet: TSQLDataSet;
  i: Integer;
begin
  FDateValue := Now;
  SetLength(FBlobValue, cnBlobLength);
  for i := 0 to Pred(cnBlobLength) do
    FBlobValue[i] := i;

  lDataSet := CreateDataSet(FConnection, cnInsertSQL);
  lDataSet.ParamByName('test_table_id').AsInteger := cnIDValue;
  lDataSet.ParamByName('string_field').AsString := cnStringValue;
  lDataSet.ParamByName('int32_field').AsInteger := cnInt32Value;
  lDataSet.ParamByName('double_field').AsFloat := cnDoubleValue;
  lDataSet.ParamByName('date_field').AsDateTime := FDateValue;
  lDataSet.ParamByName('memo_field').AsMemo := cnMemoValue;
  lDataSet.ParamByName('decimal_field').AsFloat := cnDecimalValue;
  lDataSet.ParamByName('int64_field').AsLargeInt := cnInt64Value;
  lDataSet.ParamByName('blob_field').AsBlob := FBlobValue;
  lDataSet.ParamByName('single_field').AsSingle := cnSingleValue;
  lDataSet.ExecSQL;
end;

procedure TDBXUtilsTests.FieldNameToPropNameTest;
begin
  CheckEqualsString('FOOBAR', FieldNameToPropName('FOO_BAR'));
  CheckEqualsString('BARFOOBAR', FieldNameToPropName('BAR_FOO_BAR'));
  CheckEqualsString('FOOBar', FieldNameToPropName('FO_O_Bar'));
  CheckEqualsString('FOOBarFOO', FieldNameToPropName('FOO_Bar__FOO'));
end;

procedure TDBXUtilsTests.PropNameToFieldNameTest;
begin
  CheckEqualsString('FOO_BAR', PropNameToFieldName('FooBar'));
  CheckEqualsString('BAR_FOO_BAR', PropNameToFieldName('BarFooBar'));
  CheckEqualsString('FOO_BAR', PropNameToFieldName('FooBAR'));
  CheckEqualsString('FOO_BARFOO', PropNameToFieldName('FooBARFoo'));
end;


procedure TDBXUtilsTests.QueryValueNullDefaultTest;
var
  lInt64: Int64;
  lInt32: Integer;
  lDouble: Double;
  lDate: TDateTime;
  lStr: string;
  lParams: TParams;
begin
  lStr := QueryValueNullDefault(FConnection, cnSelectStringField, cnStringDefault, cnStringNullDefault);
  CheckEquals(cnStringValue, lStr);
  lStr := QueryValueNullDefault(FConnection, cnSelectStringFieldNotHere, cnStringDefault, cnStringNullDefault);
  CheckEquals(cnStringDefault, lStr);
  lStr := QueryValueNullDefault(FConnection, cnSelectStringFieldNull, cnStringDefault, cnStringNullDefault);
  CheckEquals(cnStringNullDefault, lStr);

  lInt32 := QueryValueNullDefault(FConnection, cnSelectInt32Field, cnInt32Default, cnInt32NullDefault);
  CheckEquals(cnInt32Value, lInt32);
  lInt32 := QueryValueNullDefault(FConnection, cnSelectInt32FieldNotHere, cnInt32Default, cnInt32NullDefault);
  CheckEquals(cnInt32Default, lInt32);
  lInt32 := QueryValueNullDefault(FConnection, cnSelectInt32FieldNull, cnInt32Default, cnInt32NullDefault);
  CheckEquals(cnInt32NullDefault, lInt32);

  lDouble := QueryValueNullDefault(FConnection, cnSelectDoubleField, cnDoubleDefault, cnDoubleNullDefault);
  CheckEquals(cnDoubleValue, lDouble);
  lDouble := QueryValueNullDefault(FConnection, cnSelectDoubleFieldNotHere, cnDoubleDefault, cnDoubleNullDefault);
  CheckEquals(cnDoubleDefault, lDouble);
  lDouble := QueryValueNullDefault(FConnection, cnSelectDoubleFieldNull, cnDoubleDefault, cnDoubleNullDefault);
  CheckEquals(cnDoubleNullDefault, lDouble);

  lDate := QueryValueNullDefault(FConnection, cnSelectDateField, cnDateDefault, cnDateNullDefault);
  VerifyDates(FDateValue, lDate);
  lDate := QueryValueNullDefault(FConnection, cnSelectDateFieldNotHere, cnDateDefault, cnDateNullDefault);
  CheckEquals(cnDateDefault, lDate);
  lDate := QueryValueNullDefault(FConnection, cnSelectDateFieldNull, cnDateDefault, cnDateNullDefault);
  CheckEquals(cnDateNullDefault, lDate);

  lInt64 := QueryValueNullDefault(FConnection, cnSelectInt64Field, cnInt64Default, cnInt64NullDefault);
  CheckEquals(cnInt64Value, lInt64);
  lInt64 := QueryValueNullDefault(FConnection, cnSelectInt64FieldNotHere, cnInt64Default, cnInt64NullDefault);
  CheckEquals(cnInt64Default, lInt64);
  lInt64 := QueryValueNullDefault(FConnection, cnSelectInt64FieldNull, cnInt64Default, cnInt64NullDefault);
  CheckEquals(cnInt64NullDefault, lInt64);

  lParams := MakeParamList('val', ftLargeint, cnInt64Value);
  lInt64 := QueryValueNullDefault(FConnection, cnSelectInt64FieldParam, cnInt64Default, cnInt64NullDefault, lParams, False);
  CheckEquals(cnInt64Value, lInt64);

  lInt64 := QueryValueNullDefault(FConnection, cnSelectInt64FieldParamNull, cnInt64Default, cnInt64NullDefault, lParams, False);
  CheckEquals(cnInt64NullDefault, lInt64);

  lParams := MakeParamList('val', ftLargeint, cnInt64Value);
  lInt64 := QueryValueNullDefault(FConnection, cnSelectInt64FieldParam, cnInt64Default, cnInt64NullDefault, lParams, True);
  CheckEquals(cnInt64Value, lInt64);
end;

procedure TDBXUtilsTests.QueryValueTest;
var
  lInt64: Int64;
  lInt32: Integer;
  lDouble: Double;
  lDate: TDateTime;
  lStr: string;
  lParams: TParams;
begin
  lStr := QueryValue(FConnection, cnSelectStringField, cnStringDefault);
  CheckEquals(cnStringValue, lStr);
  lStr := QueryValue(FConnection, cnSelectStringFieldNotHere, cnStringDefault);
  CheckEquals(cnStringDefault, lStr);

  lInt32 := QueryValue(FConnection, cnSelectInt32Field, cnInt32Default);
  CheckEquals(cnInt32Value, lInt32);
  lInt32 := QueryValue(FConnection, cnSelectInt32FieldNotHere, cnInt32Default);
  CheckEquals(cnInt32Default, lInt32);

  lDouble := QueryValue(FConnection, cnSelectDoubleField, cnDoubleDefault);
  CheckEquals(cnDoubleValue, lDouble);
  lDouble := QueryValue(FConnection, cnSelectDoubleFieldNotHere, cnDoubleDefault);
  CheckEquals(cnDoubleDefault, lDouble);

  lDate := QueryValue(FConnection, cnSelectDateField, cnDateDefault);
  VerifyDates(FDateValue, lDate);
  lDate := QueryValue(FConnection, cnSelectDateFieldNotHere, cnDateDefault);
  CheckEquals(cnDateDefault, lDate);

  lInt64 := QueryValue(FConnection, cnSelectInt64Field, cnInt32Default);
  CheckEquals(cnInt64Value, lInt64);
  lInt64 := QueryValue(FConnection, cnSelectInt64FieldNotHere, cnInt32Default);
  CheckEquals(cnInt64Default, lInt64);

  lParams := MakeParamList('val', ftLargeint, cnInt64Value);
  lInt64 := QueryValue(FConnection, cnSelectInt64FieldParam, cnInt64Default, lParams, False);
  CheckEquals(cnInt64Value, lInt64);
  lInt64 := QueryValue(FConnection, cnSelectInt64FieldParam, cnInt64Default, lParams, True);
  CheckEquals(cnInt64Value, lInt64);

  lInt32 := QueryValue(FConnection, cnSelectInt32FieldNull, -1);
  CheckEquals(-1, lInt32);
end;

procedure TDBXUtilsTests.VerifyObject(ADataSet: TDataSet; AObject: TTestTable; ASmartID: Boolean);
begin
//    property ID: Integer read FID write FID;
//    property TestTableID: Integer read FTestTableID write FTestTableID;
//    property StringField: string read FStringField write FStringField;
//    property Int32Field: Integer read FInt32Field write FInt32Field;
//    property DoubleField: Double read FDoubleField write FDoubleField;
//    property MemoField: string read FMemoField write FMemoField;
//    property DecimalField: Double read FDecimalField write FDecimalField;
//    property Int64Field: Int64 read FInt64Field write FInt64Field;
//    property SingleField: Single read FSingleField write FSingleField;

  if ASmartID then
  begin
    CheckEquals(0, AObject.TestTableID);
    CheckEquals(ADataSet.FieldByName('TEST_TABLE_ID').AsInteger, AObject.ID);
  end
  else
  begin
    CheckEquals(0, AObject.ID);
    CheckEquals(ADataSet.FieldByName('TEST_TABLE_ID').AsInteger, AObject.TestTableID);
  end;
  CheckEqualsString(ADataSet.FieldByName('STRING_FIELD').AsString, AObject.StringField);
  CheckEquals(ADataSet.FieldByName('INT32_FIELD').AsInteger, AObject.Int32Field);
  CheckEquals(ADataSet.FieldByName('DOUBLE_FIELD').AsFloat, AObject.DoubleField);
  CheckEqualsString(ADataSet.FieldByName('MEMO_FIELD').AsString, AObject.MemoField);
  CheckEquals(ADataSet.FieldByName('DECIMAL_FIELD').AsFloat, AObject.DecimalField);
  CheckEquals(ADataSet.FieldByName('INT64_FIELD').AsLargeInt, AObject.Int64Field);
  CheckEquals(ADataSet.FieldByName('SINGLE_FIELD').AsSingle, AObject.SingleField);
end;

procedure TDBXUtilsTests.VerifyList(ADataSet: TDataSet; AList: TObjectList<TTestTable>;
  ASmartID: Boolean);
var
  lCurrent: Integer;
begin
  CheckEquals(ADataSet.RecordCount, AList.Count);
  lCurrent := 0;
  ADataSet.First;
  while not ADataSet.EOF do
  begin
    VerifyObject(ADataSet, AList[lCurrent], ASmartID);
    Inc(lCurrent);
    ADataSet.Next;
  end;
end;

procedure TDBXUtilsTests.ListFromDataSetTest;
var
  lList: TObjectList<TTestTable>;
  lDS: TDataSet;
begin
  lDS := GetClientDataSet(FConnection, cnSelectAll);
  try
    lList := TDBXUtils<TTestTable>.ListFromDataSet(lDS);
    try
      VerifyList(lDS, lList, True);
    finally
      lList.Free;
    end;

    lDS.First;
    lList := TDBXUtils<TTestTable>.ListFromDataSet(lDS, False);
    try
      VerifyList(lDS, lList, False);
    finally
      lList.Free;
    end;

  finally
    lDS.Free;
  end;
end;

procedure TDBXUtilsTests.ListFromSQLTest;
var
  lDS: TDataSet;
  lList: TObjectList<TTestTable>;
begin
  lDS := GetClientDataSet(FConnection, cnSelectAll);
  try
    lList := TDBXUtils<TTestTable>.ListFromSQL(FConnection, cnSelectAll);
    try
      VerifyList(lDS, lList, True);
    finally
      lList.Free;
    end;

    lList := TDBXUtils<TTestTable>.ListFromSQL(FConnection, cnSelectAll, False);
    try
      VerifyList(lDS, lList, False);
    finally
      lList.Free;
    end;
  finally
    lDS.Free;
  end;
end;

procedure TDBXUtilsTests.ObjectFromDataSetTest;
var
  lObj: TTestTable;
  lDS: TDataSet;
begin
  lDS := GetClientDataSet(FConnection, cnSelectAll);
  try
    lObj := TDbxUtils<TTestTable>.ObjectFromDataSet(lDS);
    try
      lDS.First;
      VerifyObject(lDS, lObj, True);
    finally
      lObj.Free;
    end;

    lObj := TDbxUtils<TTestTable>.ObjectFromDataSet(lDS, False);
    try
      lDS.First;
      VerifyObject(lDS, lObj, False);
    finally
      lObj.Free;
    end;
  finally
    lDS.Free;
  end;
end;



procedure TDBXUtilsTests.SetUp;
begin
  FConnection := CreateConnection(cnTestConnection);
  PopulateTestTable;
end;

procedure TDBXUtilsTests.TearDown;
begin
  if Assigned(FConnection) then
  begin
    ExecNoQuery(FConnection, 'delete from test_table');
    if FConnection.ConnectionState = csStateOpen then
      FConnection.Close;
    FConnection.Free;
  end;
end;

procedure TDBXUtilsTests.TorFTest;
begin
  CheckEquals('T', TOrF(True));
  CheckEquals('F', TOrF(False));
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TDBXUtilsTests.Suite);
end.

